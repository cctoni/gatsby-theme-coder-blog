---
alias: '1ff423fd629e'
heroImage: /blog/posts/introducing-prisma.png
authors: [nikolasburk]
---

import { PostTitle, Abstract } from 'gatsby-theme-coder-blog/src/components/Blog/Post/Metadata'
import Youtube from 'gatsby-theme-coder-blog/src/components/Blog/Post/Youtube'

<PostTitle>Introducing Prisma ðŸŽ‰</PostTitle>

<Abstract>
  Today we are incredibly excited to announce Prisma, an open-source GraphQL API layer for your database.
</Abstract>

**Prisma is a GraphQL database proxy turning your database into a GraphQL API.** You can use the API as foundation for your own GraphQL server or connect directly from your frontend application.

## How does Prisma work?

Prisma is a standalone component which is deployed in front of your SQL database and generates a GraphQL API. To get started and create a new GraphQL API with Prisma, you simply define your data model using GraphQL SDL and use the [Prisma CLI](https://github.com/graphcool/prisma) to deploy your changes.

Based on your data model, Prisma generates a ready-to-use GraphQL API exposing a powerful CRUD [GraphQL schema](https://blog.graph.cool/graphql-server-basics-the-schema-ac5e2950214e).

As an example, consider this data model which specifies a single User type :

```graphql
type User {
  id: ID! @unique
  name: String!
}
```

The GraphQL schema generated by Prisma will look similar to this:

```graphql
type Query {
  users(
    where: UserWhereInput
    orderBy: UserOrderByInput
    skip: Int
    after: String
    before: String
    first: Int
    last: Int
  ): [User]!
  user(where: UserWhereUniqueInput!): User
}

type Mutation {
  createUser(data: UserCreateInput!): User!
  updateUser(data: UserUpdateInput!, where: UserWhereUniqueInput!): User
  deleteUser(where: UserWhereUniqueInput!): User
}

type Subscription {
  user(where: UserSubscriptionWhereInput): UserSubscriptionPayload
}
```

With this schema, you now have full CRUD capabilities for the User type. This includes powerful options for filtering, sorting and pagination to read and write User records in the database.

## Getting started

To get started with Prisma, all you need to do is install the Prisma CLI and use its [init](https://www.prismagraphql.com/docs/reference/cli-command-reference/database-service/prisma-init-eeb1ohr4ec) command:

```bash
# Install the Prisma CLI
npm install -g prisma

# Bootstrap a Prisma service (select `database-only`)
prisma init hello-world

# Deploy your GraphQL API
cd hello-world
prisma deploy

# Start exploring the API in a Playground
prisma playground
```

> The `prisma init` command offers an interactive prompt that allows you to either explore Prisma in a _database-only_ setup or by bootstrapping a GraphQL server with Node.js or TypeScript (based on [GraphQL boilerplates](https://github.com/graphcool/graphql-boilerplate)).

Watch this short 4 minute video to learn how you can use Prisma to build a simple GraphQL server:

<Youtube videoId="20zGexpEitc" />

To learn more about how to get started with Prisma, you can check out the [**documentation**](https://www.prismagraphql.com/docs) or the following resources:

- **Quickstart**: [Node.js](https://www.prismagraphql.com/docs/1.0/quickstart/backend/node/node-phe8vai1oo), [TypeScript](https://www.prismagraphql.com/docs/1.0/quickstart/backend/typescript/typescript-rohd6ipoo4), [Prisma Basics](https://www.prismagraphql.com/docs/tutorials/prisma-basics/getting-started-ouzia3ahqu)
- **How to GraphQL**: [Building a Hackernews clone with Prisma & Node.js](https://www.howtographql.com/graphql-js/0-introduction/)

## How Prisma fits into the GraphQL ecosystem

Open-source tools like [`apollo-server`](https://github.com/apollographql/apollo-server), [`graphql-yoga`](https://www.prismagraphql.com/docs/graphql-ecosystem/graphql-yoga/overview-chaha122ho) and [GraphQL bindings](https://blog.graph.cool/reusing-composing-graphql-apis-with-graphql-bindings-80a4aa37cff5) make it (almost too) easy to get started with building your own GraphQL server. However, implementing the resolvers for your GraphQL API remains the hard technical challenge when it comes to developing GraphQL servers that go beyond simple use cases.

This is exactly what Prisma is trying to simplify. In combination with [`prisma-bindings`](https://www.prismagraphql.com/docs/graphql-ecosystem/graphql-binding/prisma-binding-gai5urai6u), it enables a straightforward implementation of your resolvers by simply [_delegating_](https://blog.graph.cool/graphql-schema-stitching-explained-schema-delegation-4c6caf468405) the execution of incoming queries to the underlying Prisma API. These are then resolved efficiently by Prismaâ€™s query engine.

![Thanks to static bindings, GraphQL developers can now benefit from autocompletion when working with GraphQL APIs (similar to GraphQL Playgrounds / GraphiQL)](https://cdn-images-1.medium.com/max/2000/1*HL-fBLNk_GHZLUAJ3va9ZQ.gif)_Thanks to static bindings, GraphQL developers can now benefit from autocompletion when working with GraphQL APIs (similar to GraphQL Playgrounds / GraphiQL)_

## A huge thanks to the community ðŸ’š

At Graphcool, our mission is to make it as easy as possible for developers to build applications with GraphQL. When we started out two years ago, the GraphQL ecosystem was still in its infancy and did not provide much tooling for developers to get started.

The best way for us to accelerate the adoption of GraphQL was by offering a Backend-as-a-Service solution, so developers could get up and running quickly with their own GraphQL backends. To not compromise on flexibility for our customers, [we open-sourced the platform in October 2017](https://blog.graph.cool/introducing-the-graphcool-framework-d9edab2a7816).

We couldnâ€™t be more excited to launch Prisma today and are incredibly thankful for being part of such an amazing developer community! âœ¨
