---
alias: 'b60cfa683511'
heroImage: /blog/posts/top-5-reasons-to-use-graphql.png
authors: [nikolasburk]
---

import { PostTitle, Abstract } from 'gatsby-theme-coder-blog/src/components/Blog/Post/Metadata'
import Youtube from 'gatsby-theme-coder-blog/src/components/Blog/Post/Youtube'

<PostTitle>Top 5 Reasons to Use GraphQL</PostTitle>

<Abstract>
  GraphQL is becoming the new standard for API development — learn the top reasons why in this article.
</Abstract>

After only two and a half years of existence, GraphQL has made its way to the forefront of API development. In this article, we explain why developers love GraphQL and unveil the major reasons for its rapid adoption.

## 1) GraphQL APIs have a strongly typed schema

One of the biggest problems with most APIs is that they’re lacking strong contracts for what their operations look like. Many developers have found themselves in situations where they needed to work with deprecated API documentation, lacking proper ways of knowing _what operations are supported_ by an API and _how to use them_.

A [GraphQL schema](https://blog.graph.cool/graphql-server-basics-the-schema-ac5e2950214e) is the backbone of every GraphQL API. It clearly defines the operations (_queries_, _mutations_ and _subscriptions_) supported by the API, including input arguments and possible responses. The schema is an unfailing contract that specifies the capabilities of an API.

> The GraphQL schema is an unfailing contract that specifies the capabilities of an API.

GraphQL schemas are strongly-typed and can be written in the simple and expressive GraphQL [Schema Definition Language](https://blog.graph.cool/graphql-sdl-schema-definition-language-6755bcb9ce51) (SDL). Thanks to the strong type-system, developers are getting many benefits that are unconceivable with schemaless APIs. As an example, build tooling can be leveraged to validate API requests and check for any errors that might occur in the communication with the API at compile-time. You might even get auto-completion for API operations in your editor!

Another benefit of the schema is that developers don’t have to manually write API documentation any more — instead it can be _auto-generated_ based on the schema that defines the API. That’s a game-changer for API development!

> [**GraphQL Server Basics: The Schema - Structure and implementation of GraphQL servers (Part I)**](https://blog.graph.cool/graphql-server-basics-the-schema-ac5e2950214e)

## 2) No more overfetching and underfetching

Developers often describe the major benefit of GraphQL with the fact that clients can retrieve exactly the data they need from the API. They don’t have to rely on REST endpoints that return predefined and fixed data structures. Instead, the client can dictate the shape of the response objects returned by the API.

This solves two problems commonly encounter with REST APIs: _overfetching and underfetching_.

> With GraphQL, the client can dictate the shape of the response objects returned by the API.

**Overfetching** means the client is retrieving data that is actually not needed at the moment when it’s being fetched. It thus drains performance (more data needs longer to be downloaded and parsed) of the app and also exhausts the user’s data plan.

A simple example for overfetching would be the following scenario: An app renders a _profile screen_ for a user which displays the user’s _name_ and _birthday_. The corresponding API endpoint that provides the information about specific users (.e.g `/users/<id>`) is designed in a way that it also returns the _address_ and _billing information_ about each user. Both are useless for the profile screen and therefore fetching them is unnecessary.

**Underfetching** is the opposite of overfetching and means that not enough data is included in an API response. This means the client needs to make additional API requests to satisfy its current data requirements.

In the worst-case, underfetching results in the infamous N+1-requests problem. This describes a situation in which a client requires information about a _list_ with `n` items. However, there is no endpoint that would satisfy the data requirements by itself. Instead, the client needs to make one request per element to gather the required information.

As an example, consider a blogging application where users can publish articles. The app now displays a list of users, where each user element should also show the _title_ of the last article published by the respective user. However, that piece of information is not included when hitting the /usersendpoint to get the list data. The app now needs to make one additional request _per user_ to the `/users/<id>/articles` endpoint, only to fetch the _title_ of the latest article.

> **Note: **With REST APIs, the issues of underfetching is often tackled by tailoring the payloads of the API endpoints to the client’s needs. In the example, this would mean that the title of the last article of each users is now also returned by the _/users_ endpoint. This approach might seem like a good solution at first, but it hinders fast product development and iterations cycles because any redesigns of the app will often require changes of the backend which are a lot more time-consuming. Learn more in the next section.

> [**How to wrap a REST API with GraphQL - 3-step tutorial how to easily turn a REST API into a GraphQL API**](https://blog.graph.cool/how-to-wrap-a-rest-api-with-graphql-8bf3fb17547d)

## 3) GraphQL enables rapid product development

GraphQL makes frontend developers’ lives easy. Thanks to GraphQL client libraries (like [Apollo](https://www.apollographql.com/client), [Relay](https://facebook.github.io/relay/) or [Urql](https://github.com/FormidableLabs/urql)) frontend developers are getting features like _caching_, _realtime_ or _optimistic UI updates_ basically for free — areas that could have _entire teams_ dedicated to work on them if it wasn’t for GraphQL.

Increased productivity among frontend developers leads to a speedup in product development. With GraphQL, it is possible to completely redesign the UI of an app without needing to touch the backend.

> “We are product people — and we designed the API that we wanted to use to build products.” Lessons from 4 Years of GraphQL, [Lee Byron](https://www.twitter.com/leeb)

<Youtube videoId="zVNrqo9XGOs" />

The process of building a GraphQL API is vastly centered around the GraphQL schema. Hence, you’ll often hear the term _schema-driven development_ in the context of GraphQL. It simply refers to a process where a feature is first _defined_ in the schema, then _implemented_ with resolver functions.

Following this process and thanks to tools like [GraphQL Faker](https://github.com/APIs-guru/graphql-faker), the frontend developers can be productive already once the schema was defined. GraphQL Faker mocks the entire GraphQL API (based on its schema definition), so frontend and backend teams can work completely independently.

> To learn more about the difference between **schema definition** and **schema implementation**, be sure to check out [this](https://blog.graph.cool/graphql-server-basics-the-schema-ac5e2950214e) article.

## 4) Composing GraphQL APIs

The idea of [schema stitching](https://blog.graph.cool/graphql-schema-stitching-explained-schema-delegation-4c6caf468405) is one of the newer ones in the GraphQL space. In short, schema stitching allows to _combine and connect multiple GraphQL APIs_ and and merge them into a single one. Similar to how a React components can be composed out of existing ones, a GraphQL API can also be composed out of existing GraphQL APIs!

> Similar to how a React components can be composed out of existing ones, a GraphQL API can also be composed out of existing GraphQL APIs!

This is extremely beneficial for client applications that would otherwise need to talk to multiple GraphQL endpoints (which can often happen with a microservice architecture or when integrating with 3rd-party APIs like GitHub, Yelp or Shopify). Thanks to schema stitching, clients only deal with a single API endpoint and all complexity of orchestrating the communication with the various services is hidden from the client.

[GraphQL bindings](https://blog.graph.cool/reusing-composing-graphql-apis-with-graphql-bindings-80a4aa37cff5) take the idea of schema stitching to the next level by enabling a simple approach to reusing and sharing GraphQL APIs.

> [**Reusing & Composing GraphQL APIs with GraphQL Bindings - With GraphQL bindings you can embed existing GraphQL APIs into your GraphQL server.**](https://blog.graph.cool/reusing-composing-graphql-apis-with-graphql-bindings-80a4aa37cff5)

## 5) Rich open-source ecosystem and an amazing community

It is only a two and a half years since GraphQL was officially released by Facebook and it is incredible how much the entire GraphQL ecosystem has matured since then.

When it came out, the only tooling available for developers to use GraphQL was the [graphql-js](https://github.com/graphql/graphql-js) reference implementation, a piece of middleware for Express.js and the GraphQL client Relay (Classic).

Today, reference implementations of the GraphQL specification are available in [various languages](http://graphql.org/code/#server-libraries) and there’s a [plethora of GraphQL clients](https://itnext.io/exploring-different-graphql-clients-d1bc69de305f). In addition, lots of tooling (like [Prisma](https://www.prisma.io/), [GraphQL Faker](https://github.com/APIs-guru/graphql-faker), [GraphQL Playground](https://github.com/graphcool/graphql-playground), [graphql-config](https://github.com/graphcool/graphql-config),…) provide seamless workflows and make for an amazing developer experience when building GraphQL APIs.

![GraphQL is used in production by many big tech companies](https://cdn-images-1.medium.com/max/2814/1*OPs5D2XrAcFI1hDay-_nEQ.png)_GraphQL is used in production by many big tech companies_

The GraphQL community is also growing rapidly. [Many small and big companies have started using it in production](http://graphql.org/users/) and more and more [GraphQL Meetups](http://graphql.org/community/upcoming-events/#meetups) are being founded all over the world. There even are entire conferences that are exclusively dedicated to GraphQL:

- [GraphQL Europe](https://www.graphql-europe.org) (Berlin)
- [GraphQL Day](https://www.graphqlday.org/) (changing locations, [first edition in Amsterdam](https://medium.com/graphql-europe/graphql-day-in-amsterdam-on-april-14-dee87bd9fc21))
- [GraphQL Summit](https://summit.graphql.com) (San Francisco)

## Get started with GraphQL today

In this article, you have learned why GraphQL is the API technology of the future. The advantages it brings to the table and the various ways how it benefits developers and improves workflows are a game-changer for how APIs are _built_ and _consumed_.

If you want to get started with GraphQL, here a few resources to help you get your feet off the ground quickly:

- [How to build a GraphQL Server with `graphql-yoga`](https://blog.graph.cool/tutorial-how-to-build-a-graphql-server-with-graphql-yoga-6da86f346e68)
- [How to GraphQL](https://www.howtographql.com/): The fullstack GraphQL tutorial
- [GraphQL boilerplates](https://github.com/graphql-boilerplates): Starter kits for GraphQL projects with Node, TypeScript, React, Vue,…
